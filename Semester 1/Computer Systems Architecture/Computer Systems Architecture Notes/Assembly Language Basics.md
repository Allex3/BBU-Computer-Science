### What is an assembler and assembly language?

>[!info] What is Assembly Language?
>A programming language in which the basic instructions set corresponds with the machine operations and which data structures are the machine primary structures. This is a **symbolic language. Symbols - Mnemonics (keyword, names) + labels**
>

**Assembler** = translation program

>[!important] What does an assembler do ?! It verifies the syntactic correctness of the assembly file, then it is GENERATING the BYTES of the instructions.


## How does an assembler work?

### What does an assembler work with?

- **Labels** - used-defined names for pointing to data or memory areas
	- is an offset specification!
	- pointing to a certain memory area inside the **code segment** - code labels
- **Instructions** - mnemonics which suggest the underlying action. The assembler generates the bytes that codifies the corresponding instruction
- **Directive** -  given to the assembler for correctly generating the corresponding bytes.
	- Ex: relationships between object modules, segment definitions, conditional assembling, data definition directives
- **Location counter** - an integer number managed by the assembler for very separate memory segment. At any given moment, the value of the location counter is the number of the generated bytes correspondingly with the instructions and the directives already met in that segment (the current offset inside that segment). The programmer can use this value (read-only access!) by specifying in the source code the '$' symbol. **Every segment has its own location counter!!**
[[Location Counter]]


>[!info] $ - offset - pointer type, address; **location we're at in current section** (or segment if there's no section)
>`$$` - offset - pointer type, address ; the start of the **current section** (if there's no section it is the beginning of the *segment*)

- `$-$$` - address of the beginning of the segment
### Source line format

In x86 asm language, the source line is: 
>[!important] $$[label[:]][prefixes][mnemonic][operands][;comment]$$

**Examples:**
```nasm
here: jmp here      ;label+mnemonic+operand+comment
repz cmpsd          ;prefix+mnemonic+comment
start:              ;label+comment
					;just a comment, which could be missed
a dw 19872, 42h     ;label+mnemonic+ 2 operands + comment

len equ $-a ; label + mnemonic + $-a (operand) + comment
```


### Two categories of labels

1. **Code Labels**
2. **Data Labels**

>[!important] The *value* associated with a label in assembly language is an integer number representing the *address* of the instruction or directive following that label
>The assembler 'replaces' every offset available at assembler time (labels or address of variables) with that specific numerical offset.

### Expressions

expression -> operands + operators. 
	*Operators* indicate how to combine the operands for building an expression
	**Expressions** are evaluated at assembly time (their values are computable at assembly time, except for the operands...)

#### Operands specification rules

##### Instructions operands may be specified in 3 different ways, called **specification modes**
>[!important] The 3 operand types are: *immediate operands, register operands* and *memory operands*.
> Their values are computed at *assembly time* for the immediate operands and for the direct addressed operands (the offset part only!) (**THE CONSTANTS** (**AT ASSEMBLY TIME ONLY THE OFFSET IS AVAILABLE**)
 At *loading time* for memory operands in direct addressing mode (as a complete FAR address - segment address is determinable here so the whole FAR address is known now!) - this step involves a so called ADDRESS RELOCATION PROCESS (adjusting an address by fixing its segment part)
 At *run time* for the registers operands and for indirectly accessed memory operands.

 `??:offset` (assembly time)
 `0708:offset` (loading time) (0708 - OS descriptor, not the effective address)



#### Memory addressing operands
- 2 types of memory operands: *direct addressing operands* and *indirect addressing operands*

>[!important] **The offset of a direct addressing operand is computed at *assembly time***. The address of every operand relative to the executable program's structure (establishing the segments to which the computed offsets are relative to) is computed *at linking time*. The actual physical address is computed *at loading time*

>[!important] Every jump label is prefixed by the segment's register ?? CS:label

- **CS**  for code labels target of the control of transfer instructions` (jmp, call, ret, jz,` etc)
- **SS** in SIB addressing when using EBP or ESP as *base* (no matter of *index* or *scale*)
>[!important] **DS** is used for the rest of data accesses!!! (if not from CS or SS)

>[!info] REMINDER: CS, DS, SS, ES contain the *descriptor* of the segment of that type that is active right now

```nasm
JMP FAR CS:...
JMP FAR DS:...
JMP FAR [label2] ????
```
