Assembly language is a **symbolic language. Symbols = mnemonics + labels**

- **Labels** - used-defined names for pointing to data or memory areas
	- is an offset specification!
	- pointing to a certain memory area inside the **code segment** - code labels
- **Instructions** - mnemonics which suggest the underlying action. The assembler generates the bytes that codifies the corresponding instruction
- **Directive** -  given to the assembler for correctly generating the corresponding bytes.
	- Ex: relationships between object modules, segment definitions, conditional assembling, data definition directives
- **Location counter** - an integer number managed by the assembler for very separate memory segment. At any given moment, the value of the location counter is the number of the generated bytes correspondingly with the instructions and the directives already met in that segment (the current offset inside that segment). The programmer can use this value (read-only access!) by specifying in the source code the '$' symbol. **Every segment has its own location counter!!**
	- `$` - evaluates to the assembly position at the beginning of the line containing the expression = **the current offset inside that segment** = ==location counter== - ==POINTER TYPE, offset==
	- `$$` - evaluates to the start of current segment - ==POINTER TYPE, offset==
	- `$-$$ = how far you are in a segment` = scalar, current size of section/segment
[[Location Counter]]

---

### Source line format

>[!important] $$[label[:]][prefixes][mnemonic][operands][;comment]$$

- **All** identifiers are ==case SENSITIVE==, but implicit names (keywords, mnemonics, registers) are case **insensitive**

**Label categories:**
- ==code labels== - present at the level of instructions sequences for defining the destinations of the control transfer during a program execution; can appear also in data segments
- ==data labels== - provide symbolic identification for some memory locations (contains offset); can also appear in code segments
	- ==The value associated with a **label** in assembly language is a **number representing the address of the instruction or directive following that label.**==
- **straight brackets** - denotes the value of the variable at address `p`: `[p]`
- other contexts - the name represents the **address of the variable**
As a generalization, using straight brackets always indicates accessing an operand from memory.

**Types of mnemonics:**
- ==instructions names== - actions that *guide* the processor
- ==directives names== - *guide* the assembler. They specify the particular way in which the assembler will generate the object code

==operands== - parameters which **define the values to be processed by the instructions or directives.** They can be *registers, constants, labels, expressions, keywords or other symbols*. Their semantics **depends on the mnemonic** of the associated instruction or directive.


### Expressions

- ==operators== - indicate how to combine the operands for building an expression

>[!important] ==expression== - operands + operators - **COMPUTED AT ASSEMBLY TIME** (their values are computable at assembly time, except for the operands representing registers contents, that can be evaluated only at run time – the offset specification formula)

**Operand types**: ==immediate== operands, ==register== operands, ==memory== operands. Their values are computed at:
- ==immediate== (`17, v`) and the ==direct addressed== (the offset part only: `[v]`)  operands are computed at **assembly time**:
	- ??:offset (assembly time)
- ==memory operands in direct addressing mode== (as a complete FAR address), because the segment selector is determinable only here - **loading time** - involves a process called ==ADDRESS RELOCATION PROCESS== (adjusting an address by fixing its segment part)
	- 0708:offset (loading time)
- **run time**  - ==register== operands and ==indirectly accessed memory operands== (`[ebx+2], [2*ebx+v])

#### Immediate operands - constant numeric data computable at assembly time

- specified through binary (`b, y`), octal (`q, o`), decimal (`d, t`) or hexadecimal (`h, x`) values. Can use `_` to separate groups of digits (has no effect)
	- `0ABCH - hexadeicmal`, `ABCH - symbol` - h as a suffix, or others same
	- Can also use `0x, 0h, 0b, 0d, etc.` as prefixes: `0xAb`, digits are case insensitive

>[!important] The offsets of data labels and code labels are values computable at assembly time and they remain constant during the whole program’s run-time
>`mov eax, 8 `, `mov eax, [var]` <- computable at assembly time
>determinable at assembly time based upon the order in which variables are declared in the source code and due to the dimension of representation inferred from the associated type information.

#### Register operands 

- ==Direct usage== - `mov eax, ebx`
- ==Indirect usage and addressing== - used for pointing to memory locations - `mov eax, [ebx]` 
#### Memory addressing operands

##### DIRECT addressing operands

- ==Direct addressing operands== - constant or a symbol representing the address (segment and offset) of an instruction or some data. May be **labels** (`jmp et`), **procedure names** (`call proc`), **the value of the location counter** (`b db $-a`)
	- The **offset** of a direct addressing operand is computed at **assembly time.** 
	- The ==address of every operand relative to the executable program’s structure== (**establishing the segments** to which the computed offsets are relative to) is computed at **linking time.** 
	- The== actual physical address== is computed at **loading time.**

The effective address always refers to a segment register - can be implicit by an instruction or explicit by the programmed. Rules for using an explicit specified offset operand:
- **CS** for code labels target of the control transfer instructions `(jmp, call, ret, jz etc)`;
- **SS** in **SIB** addressing when using **EBP or ESP as base** (no matter of index or scale);
- **DS** for the rest of data accesses;
- Done using `:` prefix operator: `ES:[var], DS:[ebx+eax*2-a]`, ES can ONLY be explicitly specified or used in string instructions (`MOVSB`, `ES:[EDI]` I think it was..)
	- Or `JMP FAR CS:..., JMP FAR DS:... JMP FAR [label]`

##### INDIRECT addressing operands

- ==indirect addressing operands== - use registers for pointing to memory addresses - suited for dynamic data operations (register values known only at run time)
	- indirectly accessing a memory operand formula: `[base_register + index_register*scale + constant]`, constant - computable at assembly time, can be immediate or offset: `[ebx+edi+table+6], table and 6 are constants`
	- base/index usually used to refer to an array, iterating through it
			- `mov dh, [edx+ecx*4+3]` - array at address `edx` of `dwords`, so we iterate `4` bytes at a time, and `+3` says "go to the last byte of an element" (highest byte because little-endian)

From a syntactic point of view, when the **operand is not specified by the complete formula, some of the components missing** (for example when "* scale" is not present), the assembler will solve the possible **ambiguity** by an analysis process of all possible equivalent encoding forms, choosing 
the shortest finally.

Also, in addition to solving such ambiguities, the assembler also **allows non-standard expressions,** ==with the condition to be in the end transformable into the above standard form.==
[[WHAT SEGMENT WILL BE ACCESSED|Ambiguity examples]]

#### Using operators

**Operators** – used for combining, comparing, modifying and analysing the operands.

**Operators perform computations only with constant SCALAR values computable at assembly time** , ==does not work on pointers! Cannot do ~a, !a, a+b, a and b, NOT SCALARS==(scalar values = constant immediate values), with the exception of adding and/or subtracting a constant from a pointer (which will issue a pointer data type) and with the exception of the offset computation formula (which supports the ‘+’ operator). While **Instructions** perform computations with values that may remain unknown (and this is generally the case) until run time.
- ==Expression evaluation is done on 64 bits, ==the final results being afterwards adjusted accordingly to the size of available in the available usage context of that expression.
- For example the addition operator (+) performs addition at assembly time and the ADD instruction performs addition during run time.
![[Operators.png]]

##### Bit shifting operators
- `expression >> how_many, expression << how_many`, shift all the bits `how_many` positions
##### Bitwise operators
Bitwise operators perform bit-level logical operations for the operand(s) of an expression. The resulting expressions have constant values.
##### The segment specification operator
 - The segment specifier operator (:) performs the FAR address computation of a variable or label relative to a certain segment. Its syntax is: `segment:expression` (`[ss:ebx+4]` relative to SS, `10h:var`, 10h selector)

##### Type operators
- They specify the types of some expressions or operands stored in memory. Syntax:
	- `type expression`
		- `type`: `BYTE, WORD, DWORD, QWORD, TWORD`, causes `expression` to temporarily (on that instruction) have size `type`
			- for ==memory-stored operators: ==`byte, dword, qword, tword` having size of `1, 2, 4, 8, 10 bytes`
				- `mov [v],0 ; syntax error – operation size not specified`
			- for ==code labels== `type` is either **NEAR** (4 bytes address) or **FAR** (6 bytes address)
		- When we **need** a type specifier:
			- `mov [mem], ...`, `(i)div [mem], (i)mul [mem]`, `push [mem], pop [mem]`
			- Exceptions: `push 15, ambiguity will be solved as push dword 15`
`mov ax, [ebx]` – the source operand doesn't have an associated data type (it represents only a start of a memory area) and because of that, in the case of our MOV instruction the destination operand is the one that decides the data type of the transfer (a word in this case), and the transfer will be made accordingly to the little endian representation.

### Directives

>[!important] Directives direct the way in which code and data are generated during assembling

---

#### The SEGMENT directive

**SEGMENT** directive allows targeting the bytes of code or of data emitted by an assembler to a given segment, having a name and some specific characteristics.
- `SEGMENT name [type] [ALIGN=alignment] [combination] [usage] [CLASS=class]`
- ==name== - segment address (32 bits) corresponding to the memory segment's position during run-time (`$$`)
- Except the name, all the other fields are **optional** and the order in which they are specified does not matter
- The ==optional arguments== **alignment, combination, usage and 'class'** give the necessary information regarding the way in which segments must be loaded and combined in memory to the **link-editor** and the **assembler**
	- ==type== - select the **usage** mode of the segment:
		- **code** (text) - code segment, which can be executed, not written
		- **data** (bss) - data segment allowing reading and writing but NOT execution (**implicit value**) 
		- **rdata** - can only be read, contains definitions of constant data
	- ==alignment== - the multiple of the bytes number from which that segment may start (powers of 2 between 2 and 4096). **implicitly ALIGN=1, can start from any address**
	- ==combination== - controls the way in which similar named segments from other modules will be combined with the current segment at linking time. 
		- **public** - indicates to the link editor to concatenate this segment with other segments with the same name, obtaining a single segment having the length the sum of concatenated segments’ lengths
		- **common** - specifies that the beginning of this segment must overlap with the beginning of all segments with the same name, obtaining a segment having the length equal to the length of the larger segment with the same name.
		- **PRIVATE** - indicates to the link editor that this segment cannot be combined with others with the same name.
		- **STACK** - the segments with the same name will be concatenated. During run time the resulted segment will be the stack segment.
		- **IMPLICITLY** it is always **PUBLIC**
	- ==usage== - allows choosing another word size than the default 16 bits one
	- =='class'== - has the task to allow choosing the order in which the link editor puts the segments in memory. All the segments that have the same class will be placed in a contiguous block of memory whatever their order in the source code.
		- **No implicit value exists,** it being undefined when its specification is missing, leading though to NOT concatenating all the program’s segments defined so in a continuous memory block.
	- `segment code use32 class=CODE, segment data use32 class=DATA`
 

#### Data definition directives

**Data definition** (unique) = ==declaration== (NOT unique) (attributes specification) + ==allocation== (UNIQUE) (reserving required mem. space) 
**data type** = size of representation – byte, word, doubleword or quadword

General form of a ==data definition source line:==
- `[name] data_type expression_list`
- `[name] allocation_type factor`
- `[name] TIMES factor data_type expression_list`, where name is a label for data referral
- The ==data type== is the size of representation and its value will be the address of its first byte.
- ==`factor`== is a number which shows how many times the ==`expression_list`== is repeated
- ==`Data_type`== is a data definition directive, one of the following: DB, DW, DD, DQ, DT
- After a data definition directive may appear more than one value, thereby allowing declaration and initialization of arrays. For example, the declaration: `Table dw 1, 2, 3, 4, 5`
- ==allocation_type== is a uninitialized data reservation directive: `RESB, RESW, RESD, RESQ, REST`
- ==`TIMES`== directive allows repeated assembly of an instruction or data definition: `Table TIMES 80 DB 'ab'` creates an 'array' of `80*2` bytes, each two being `'a' and 'b'`


**EQU Directive** - allows assigning a numeric value or a string during assembly time to a label without allocating any memory space or bytes generation
	- `name EQU expression` -  `BUFFER_SIZE EQU 1000H`, `EXCLAMATION_MARK EQU '!'`, `INDEX_START EQU BUFFER_SIZE/2`

### Error types in CS:
#### **ASSEMBLY ERROR** = Syntax Error - diagnosed by assembler / compiler ! - eroare de asamblare
- because an assembler generates bytes 

#### Run-time error (execution error) - program crashes - it stops executing
- e.g.: **Stack overflow**

#### Logical error = program runs until its end or remains blocked in an infinite loop ... if it functions until its end, it functions LOGICALLY WRONG obtaining a totally different result/output than the envisioned ones

#### Fatal: Linking Error  !!! 
- For example, in the case of a variable defined multiple times in a multimodule program ... if we have 17 modules, a variable must be defined ONLY in a SINGLE module ! If it is defined in 2 or more modules, a "Fatal: Linking error - Duplicate definition for symbol..." will be obtained!
##### The steps followed by a program from source code to run-time:
- Syntactic checking (done by **assembler/compiler/interpreter**)
- **OBJ** files are generated by the **assembler/compiler**
- **Linking phase** (performed by a **LINKER** = a tool provided by the **OS**, which checks the possible **DEPENDENCIES** between the **OBJ files/modules**). The result is, in windows, **.EXE** file
- You (the user) are activating your exe file by clicking or entering
- The **LOADER** of the **OS** is looking for the required RAM memory space for your EXE file. When finding it, it loads the EXE file AND performs ADDRESS RELOCATION - ==loading phase==, where are the data segments of the program, their `file descriptor`
- In the end the loader gives control to the processor by specifying THE PROGRAM's ENTRY POINT (ex: start label) !!! The run-time phase begins now!