<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>repository API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>repository</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="repository.BinaryRepository"><code class="flex name class">
<span>class <span class="ident">BinaryRepository</span></span>
<span>(</span><span>binary_file_path: str = '\\repository\\expenses.bin')</span>
</code></dt>
<dd>
<div class="desc"><p>This class handles Expenses stored in a binary file using the pickle module.</p>
<p>It inherits from the MemoryRepository class, because it makes use of the add() and remove() methods from it, and it also instantiates a list of expenses in memory, that updates at the same time as the binary file.
We work with that list of expenses in memory for Services compatibility, so we make use of the MemoryRepository class methods too.</p>
<p>However, in this class we have load and save methods, which load the Expenses from the binary file into the list of expenses in memory, and, respectively, output the list of expenses from memory into the binary file, serializing with pickle.</p>
<p>Initializes by loading into a list of expenses from memory, the expenses from the binary file found at a given relative path.</p>
<p>The initializer of the class BinaryRepository, loads the contents of the file into memory as a list of expenses.
:param binary_file_path: The relative path of the binary file we use</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BinaryRepository(MemoryRepository):
    &#34;&#34;&#34;
    This class handles Expenses stored in a binary file using the pickle module.

    It inherits from the MemoryRepository class, because it makes use of the add() and remove() methods from it, and it also instantiates a list of expenses in memory, that updates at the same time as the binary file.
    We work with that list of expenses in memory for Services compatibility, so we make use of the MemoryRepository class methods too.

    However, in this class we have load and save methods, which load the Expenses from the binary file into the list of expenses in memory, and, respectively, output the list of expenses from memory into the binary file, serializing with pickle.

    Initializes by loading into a list of expenses from memory, the expenses from the binary file found at a given relative path.
    &#34;&#34;&#34;
    def __init__(self, binary_file_path: str = &#34;\\repository\\expenses.bin&#34;):
        &#34;&#34;&#34;
        The initializer of the class BinaryRepository, loads the contents of the file into memory as a list of expenses.
        :param binary_file_path: The relative path of the binary file we use
        &#34;&#34;&#34;
        super().__init__(0)
        self.__binary_file_path = binary_file_path
        self.__load()

    def __load(self) -&gt; None:
        &#34;&#34;&#34;
        Loads into a list of expenses the expenses data stored in a binary file, using pickle.
        :return: None
        &#34;&#34;&#34;
        try:
            file = open(self.__binary_file_path, &#34;rb&#34;)
            self._expenses = pickle.load(file)
            file.close()
        except FileNotFoundError:
            pass

    def __save(self):
        &#34;&#34;&#34;
        Saves in the binary file the contents of the list of expenses from memory, using serialization with pickle.
        :return: None
        &#34;&#34;&#34;
        file = open(self.__binary_file_path, &#34;wb&#34;)
        pickle.dump(self._expenses, file)
        file.close()

    def add(self, day: int, amount: int, type: str) -&gt; None:
        &#34;&#34;&#34;
        Add an expense in the binary file of expenses and also in the list of expenses from memory
        :param day: The day of the expense
        :param amount: The amount in money of the expense
        :param type: The type of the expense
        :return: None
        &#34;&#34;&#34;
        super().add(day, amount, type)
        self.__save()

    def remove(self, index: int) -&gt; None:
        &#34;&#34;&#34;
        Removes an expense from expenses.bin and also from the list of expenses
        :param index: The index of that expense in the list of expenses from memory
        :return: None
        &#34;&#34;&#34;
        if not (0&lt;= index &lt; len(self._expenses)):
            raise IndexError(&#34;The object you try to remove does not exist.&#34;)
        super().remove(index)
        self.__save()

    def undo(self, last_expenses: list[Expense]) -&gt; None:
        &#34;&#34;&#34;
        Goes back one change made to the list of expenses (consequently, modify the file too)
        :param last_expenses: The list of expenses without the last change
        :return: None
        &#34;&#34;&#34;
        self._expenses = last_expenses
        self.__save()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="repository.MemoryRepository" href="#repository.MemoryRepository">MemoryRepository</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="repository.BinaryRepository.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, day: int, amount: int, type: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add an expense in the binary file of expenses and also in the list of expenses from memory
:param day: The day of the expense
:param amount: The amount in money of the expense
:param type: The type of the expense
:return: None</p></div>
</dd>
<dt id="repository.BinaryRepository.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, index: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Removes an expense from expenses.bin and also from the list of expenses
:param index: The index of that expense in the list of expenses from memory
:return: None</p></div>
</dd>
<dt id="repository.BinaryRepository.undo"><code class="name flex">
<span>def <span class="ident">undo</span></span>(<span>self, last_expenses: list[src.domain.expense.Expense]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Goes back one change made to the list of expenses (consequently, modify the file too)
:param last_expenses: The list of expenses without the last change
:return: None</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="repository.MemoryRepository" href="#repository.MemoryRepository">MemoryRepository</a></b></code>:
<ul class="hlist">
<li><code><a title="repository.MemoryRepository.CREATE_TABLE_STRING" href="#repository.MemoryRepository.CREATE_TABLE_STRING">CREATE_TABLE_STRING</a></code></li>
<li><code><a title="repository.MemoryRepository.DROP_TABLE_STRING" href="#repository.MemoryRepository.DROP_TABLE_STRING">DROP_TABLE_STRING</a></code></li>
<li><code><a title="repository.MemoryRepository.expense_to_json_format" href="#repository.MemoryRepository.expense_to_json_format">expense_to_json_format</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="repository.DBRepository"><code class="flex name class">
<span>class <span class="ident">DBRepository</span></span>
<span>(</span><span>db_file_path: str = 'repository/expenses.json')</span>
</code></dt>
<dd>
<div class="desc"><p>This class handles Expenses stored in a DB file using the mysql.connector module.</p>
<p>It inherits from the MemoryRepository class, because it makes use of the add() and remove() methods from it, and it also instantiates a list of expenses in memory, that updates at the same time as the DB file.
We work with that list of expenses in memory for Services compatibility, so we make use of the MemoryRepository class methods too.</p>
<p>However, in this class we have load and save methods, which load the Expenses from the DB file into the list of expenses in memory, and, respectively, output the list of expenses from memory into the DB file, using the JSON module to format easier.</p>
<p>Initializes by loading into a list of expenses from memory, the expenses from the DB sql file found at a given relative path.</p>
<p>The initializer of the DBRepository class, which loads the expenses from the DB sql file into a list of expenses in memory, to work with.
:param db_file_path: The relative path of the json file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DBRepository(MemoryRepository):
    &#34;&#34;&#34;
        This class handles Expenses stored in a DB file using the mysql.connector module.

        It inherits from the MemoryRepository class, because it makes use of the add() and remove() methods from it, and it also instantiates a list of expenses in memory, that updates at the same time as the DB file.
        We work with that list of expenses in memory for Services compatibility, so we make use of the MemoryRepository class methods too.

        However, in this class we have load and save methods, which load the Expenses from the DB file into the list of expenses in memory, and, respectively, output the list of expenses from memory into the DB file, using the JSON module to format easier.

        Initializes by loading into a list of expenses from memory, the expenses from the DB sql file found at a given relative path.
    &#34;&#34;&#34;
    def __init__(self, db_file_path: str = &#34;repository/expenses.json&#34;):
        &#34;&#34;&#34;
        The initializer of the DBRepository class, which loads the expenses from the DB sql file into a list of expenses in memory, to work with.
        :param db_file_path: The relative path of the json file
        &#34;&#34;&#34;
        super().__init__(0)
        self.__db_file_path = db_file_path
        self.__load()

    def __load(self) -&gt; None:
        &#34;&#34;&#34;
        Load the list of expenses from the JSON file in memory, converting the contents of the file to a dictionary, then to a list of instances of the Expense class
        :return: None
        &#34;&#34;&#34;

        mydb = mysql.connector.connect(
            host=&#34;localhost&#34;,
            user=&#34;root&#34;,
            password=&#34;alex&#34;,
            database=&#34;expenses&#34;
        )
        cursor = mydb.cursor()
        cursor.execute(&#34;&#34;&#34;SELECT * FROM expenses&#34;&#34;&#34;)
        expenses_table = cursor.fetchall() # get all the rows from the table to output them in memory list
        # The result is a list of tuples!
        for expense_row in expenses_table:
            self._expenses.append(Expense(int(expense_row[0]), int(expense_row[1]), expense_row[2]))
        mydb.close()

    def __save(self) -&gt; None:
        &#34;&#34;&#34;
        Saves the list of expenses from memory into the DB file provided
        :return: None
        &#34;&#34;&#34;
        mydb = mysql.connector.connect(
            host=&#34;localhost&#34;,
            user=&#34;root&#34;,
            password=&#34;alex&#34;,
            database=&#34;expenses&#34;
        )
        cursor = mydb.cursor()
        try:
            cursor.execute(self.DROP_TABLE_STRING)
            cursor.execute(self.CREATE_TABLE_STRING)
            for expense in self._expenses:
                cursor.execute(f&#34;&#34;&#34;INSERT INTO expenses(
                day, amount, type)
                 VALUES ({str(expense.day)}, {str(expense.amount)}, &#39;{str(expense.type)}&#39;)&#34;&#34;&#34;)
            mydb.commit()
        except:
            mydb.rollback()
        mydb.close()

    def add(self, day: int, amount: int, type: str) -&gt; None:
        &#34;&#34;&#34;
        Add an expense in the DB file and also in the list of expenses from memory
        :param day: The day of the expense
        :param amount: The amount in money of the expense
        :param type: The type of the expense
        :return: None
        &#34;&#34;&#34;
        super().add(day, amount, type)
        self.__save()

    def remove(self, index: int) -&gt; None:
        &#34;&#34;&#34;
        Removes an expense from expenses.json and also from the list of expenses in memory
        :param index: The index of that expense in the list of expenses from memory, that mirrors the JSON data structure to work easier with it
        :return: None
        &#34;&#34;&#34;
        super().remove(index)
        self.__save()

    def undo(self, last_expenses: list[Expense]) -&gt; None:
        &#34;&#34;&#34;
            Goes back one change made to the list of expenses (consequently, modify the file too)
            :param last_expenses: The list of expenses without the last change
            :return: None
        &#34;&#34;&#34;
        self._expenses = last_expenses
        self.__save()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="repository.MemoryRepository" href="#repository.MemoryRepository">MemoryRepository</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="repository.DBRepository.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, day: int, amount: int, type: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add an expense in the DB file and also in the list of expenses from memory
:param day: The day of the expense
:param amount: The amount in money of the expense
:param type: The type of the expense
:return: None</p></div>
</dd>
<dt id="repository.DBRepository.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, index: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Removes an expense from expenses.json and also from the list of expenses in memory
:param index: The index of that expense in the list of expenses from memory, that mirrors the JSON data structure to work easier with it
:return: None</p></div>
</dd>
<dt id="repository.DBRepository.undo"><code class="name flex">
<span>def <span class="ident">undo</span></span>(<span>self, last_expenses: list[src.domain.expense.Expense]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Goes back one change made to the list of expenses (consequently, modify the file too)
:param last_expenses: The list of expenses without the last change
:return: None</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="repository.MemoryRepository" href="#repository.MemoryRepository">MemoryRepository</a></b></code>:
<ul class="hlist">
<li><code><a title="repository.MemoryRepository.CREATE_TABLE_STRING" href="#repository.MemoryRepository.CREATE_TABLE_STRING">CREATE_TABLE_STRING</a></code></li>
<li><code><a title="repository.MemoryRepository.DROP_TABLE_STRING" href="#repository.MemoryRepository.DROP_TABLE_STRING">DROP_TABLE_STRING</a></code></li>
<li><code><a title="repository.MemoryRepository.expense_to_json_format" href="#repository.MemoryRepository.expense_to_json_format">expense_to_json_format</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="repository.JSONRepository"><code class="flex name class">
<span>class <span class="ident">JSONRepository</span></span>
<span>(</span><span>json_file_path: str = 'repository/expenses.json')</span>
</code></dt>
<dd>
<div class="desc"><p>This class handles Expenses stored in a JSON file using the JSON module.</p>
<p>It inherits from the MemoryRepository class, because it makes use of the add() and remove() methods from it, and it also instantiates a list of expenses in memory, that updates at the same time as the JSON file.
We work with that list of expenses in memory for Services compatibility, so we make use of the MemoryRepository class methods too.</p>
<p>However, in this class we have load and save methods, which load the Expenses from the JSON file into the list of expenses in memory, and, respectively, output the list of expenses from memory into the JSON file, using the JSON module to format easier.</p>
<p>Initializes by loading into a list of expenses from memory, the expenses from the JSON file found at a given relative path.</p>
<p>The initializer of the JSONRepository class, which loads the expenses from the JSON file into a list of expenses in memory, to work with.
:param json_file_path: The relative path of the json file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JSONRepository(MemoryRepository):
    &#34;&#34;&#34;
        This class handles Expenses stored in a JSON file using the JSON module.

        It inherits from the MemoryRepository class, because it makes use of the add() and remove() methods from it, and it also instantiates a list of expenses in memory, that updates at the same time as the JSON file.
        We work with that list of expenses in memory for Services compatibility, so we make use of the MemoryRepository class methods too.

        However, in this class we have load and save methods, which load the Expenses from the JSON file into the list of expenses in memory, and, respectively, output the list of expenses from memory into the JSON file, using the JSON module to format easier.

        Initializes by loading into a list of expenses from memory, the expenses from the JSON file found at a given relative path.
    &#34;&#34;&#34;
    def __init__(self, json_file_path: str = &#34;repository/expenses.json&#34;):
        &#34;&#34;&#34;
        The initializer of the JSONRepository class, which loads the expenses from the JSON file into a list of expenses in memory, to work with.
        :param json_file_path: The relative path of the json file
        &#34;&#34;&#34;
        super().__init__(0)
        self.__json_file_path = json_file_path
        self.__load()

    def __load(self) -&gt; None:
        &#34;&#34;&#34;
        Load the list of expenses from the JSON file in memory, converting the contents of the file to a dictionary, then to a list of instances of the Expense class
        :return: None
        &#34;&#34;&#34;
        file = open(self.__json_file_path, &#34;r&#34;)
        json_expenses = json.load(file)[&#34;expenses&#34;]
        self._expenses = [Expense(int(e[&#34;day&#34;]), int(e[&#34;amount&#34;]), e[&#34;type&#34;]) for e in json_expenses]

    def __save(self) -&gt; None:
        &#34;&#34;&#34;
        Saves the list of expenses from memory into the json file provided, using a function to convert the expenses into a dictionary of the list of expenses, where the expenses are each a dictionary, so we use the JSON module to convert them.
        :return: None
        &#34;&#34;&#34;
        expenses_json = {&#34;expenses&#34;: [super().expense_to_json_format(expense) for expense in self._expenses]}
        json_file = open(self.__json_file_path, &#34;w&#34;)
        json_file.write(json.dumps(expenses_json, indent=4))

    def add(self, day: int, amount: int, type: str) -&gt; None:
        &#34;&#34;&#34;
        Add an expense in the JSON file and expenses and also in the list of expenses from memory
        :param day: The day of the expense
        :param amount: The amount in money of the expense
        :param type: The type of the expense
        :return: None
        &#34;&#34;&#34;
        super().add(day, amount, type)
        self.__save()

    def remove(self, index: int) -&gt; None:
        &#34;&#34;&#34;
        Removes an expense from expenses.json and also from the list of expenses in memory
        :param index: The index of that expense in the list of expenses from memory, that mirrors the JSON data structure to work easier with it
        :return: None
        &#34;&#34;&#34;
        super().remove(index)
        self.__save()

    def undo(self, last_expenses: list[Expense]) -&gt; None:
        &#34;&#34;&#34;
            Goes back one change made to the list of expenses (consequently, modify the file too)
            :param last_expenses: The list of expenses without the last change
            :return: None
        &#34;&#34;&#34;
        self._expenses = last_expenses
        self.__save()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="repository.MemoryRepository" href="#repository.MemoryRepository">MemoryRepository</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="repository.JSONRepository.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, day: int, amount: int, type: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add an expense in the JSON file and expenses and also in the list of expenses from memory
:param day: The day of the expense
:param amount: The amount in money of the expense
:param type: The type of the expense
:return: None</p></div>
</dd>
<dt id="repository.JSONRepository.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, index: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Removes an expense from expenses.json and also from the list of expenses in memory
:param index: The index of that expense in the list of expenses from memory, that mirrors the JSON data structure to work easier with it
:return: None</p></div>
</dd>
<dt id="repository.JSONRepository.undo"><code class="name flex">
<span>def <span class="ident">undo</span></span>(<span>self, last_expenses: list[src.domain.expense.Expense]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Goes back one change made to the list of expenses (consequently, modify the file too)
:param last_expenses: The list of expenses without the last change
:return: None</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="repository.MemoryRepository" href="#repository.MemoryRepository">MemoryRepository</a></b></code>:
<ul class="hlist">
<li><code><a title="repository.MemoryRepository.CREATE_TABLE_STRING" href="#repository.MemoryRepository.CREATE_TABLE_STRING">CREATE_TABLE_STRING</a></code></li>
<li><code><a title="repository.MemoryRepository.DROP_TABLE_STRING" href="#repository.MemoryRepository.DROP_TABLE_STRING">DROP_TABLE_STRING</a></code></li>
<li><code><a title="repository.MemoryRepository.expense_to_json_format" href="#repository.MemoryRepository.expense_to_json_format">expense_to_json_format</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="repository.MemoryRepository"><code class="flex name class">
<span>class <span class="ident">MemoryRepository</span></span>
<span>(</span><span>n: int, text_file_path: str = 'repository/expenses.txt', binary_file_path: str = '\\repository\\expenses.bin', json_file_path: str = 'repository/expenses.json', db_path: str = 'repository/expenses.sql')</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to store and handle memory instances of the Expense class, the instances being discarded at program exit</p>
<p>If you need to save the expenses information, you can do so by using the classes derived from this one (ex: TextFileRepository, which stores Expenses in .txt files, etc.)</p>
<p>Initializes with a random list of n instances of the Expense class, which are also stored outside of the program, if the files to store in are empty.</p>
<h2 id="functions">Functions</h2>
<p>add(day, amount, type) -&gt; Adds an expense to the list _expenses, initialized with the arguments day, amount and type.</p>
<p>remove(index) -&gt; Removes the Expense at a given index in the list of expenses.</p>
<p>__generate_expenses(number_of_expenses) -&gt; generates a list of random Expenses</p>
<p>undo(last_expenses) (Sets the list to a list given as argument (this list is the last list of the history container from the services class.))</p>
<p>Uses <strong>len</strong> to return the length of the list of expenses</p>
<p>Uses <strong>getitem</strong> to return the expense at a given index from the list of expenses</p>
<p>Notes</p>
<hr>
<p>These magic methods and the above methods are also used by the classes which inherit from it.</p>
<p>Initializer of the MemoryRepository Class, initializes the list of expenses with some random expenses and inputs them in some files, if they are empty.
:param n: The number of random expenses to generate
:param text_file_path: The relative path of the text file
:param binary_file_path: The relative path of the binary file
:param json_file_path: The relative path of the json file
:param db_path: The relative path of the database file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemoryRepository():
    &#34;&#34;&#34;
    This class is used to store and handle memory instances of the Expense class, the instances being discarded at program exit

    If you need to save the expenses information, you can do so by using the classes derived from this one (ex: TextFileRepository, which stores Expenses in .txt files, etc.)

    Initializes with a random list of n instances of the Expense class, which are also stored outside of the program, if the files to store in are empty.

    Functions
    ---------
    add(day, amount, type) -&gt; Adds an expense to the list _expenses, initialized with the arguments day, amount and type.

    remove(index) -&gt; Removes the Expense at a given index in the list of expenses.

     __generate_expenses(number_of_expenses) -&gt; generates a list of random Expenses

     undo(last_expenses) (Sets the list to a list given as argument (this list is the last list of the history container from the services class.))

     Uses __len__ to return the length of the list of expenses

     Uses __getitem__ to return the expense at a given index from the list of expenses

     Notes
     -----
     These magic methods and the above methods are also used by the classes which inherit from it.
    &#34;&#34;&#34;
    CREATE_TABLE_STRING = &#34;CREATE TABLE expenses (day varchar(255), amount varchar(255), type varchar(255))&#34;
    DROP_TABLE_STRING = &#34;DROP TABLE expenses&#34;
    def __init__(self, n: int, text_file_path: str = &#34;repository/expenses.txt&#34;, binary_file_path: str = &#34;\\repository\\expenses.bin&#34;, json_file_path: str = &#34;repository/expenses.json&#34;, db_path: str = &#34;repository/expenses.sql&#34;):
        &#34;&#34;&#34;
        Initializer of the MemoryRepository Class, initializes the list of expenses with some random expenses and inputs them in some files, if they are empty.
        :param n: The number of random expenses to generate
        :param text_file_path: The relative path of the text file
        :param binary_file_path: The relative path of the binary file
        :param json_file_path: The relative path of the json file
        :param db_path: The relative path of the database file
        &#34;&#34;&#34;
        self._expenses = []
        self.__generate_expenses(n)

        # If the input is 0, it just means we started from a storage file
        if n==0:
            return
        # Fill the text file

        text_file = open(text_file_path, &#34;r&#34;)
        if text_file.read() == &#34;&#34;: #There are no generated expenses ever, put them in the file
            text_file.close()
            text_file = open(text_file_path, &#34;w&#34;)
            for i in range(10):
                text_file.write(f&#34;{str(self._expenses[i])}\n&#34;)
        text_file.close()

        # Fill the binary file
        binary_file_path = os.getcwd() + binary_file_path
        if (os.path.getsize(binary_file_path)) == 0:
            binary_file = open(binary_file_path, &#34;wb&#34;)
            pickle.dump(self._expenses, binary_file)

        # Fill the JSON File
        json_file = open(json_file_path, &#34;r&#34;)
        if json_file.read() == &#34;&#34;:
            json_file.close()
            expenses_json = {&#34;expenses&#34;: [self.expense_to_json_format(expense) for expense in self._expenses]}
            json_file = open(json_file_path, &#34;w&#34;)
            json_file.write(json.dumps(expenses_json, indent=4))
        json_file.close()

        #Fill the database
        mydb = mysql.connector.connect(
            host = &#34;localhost&#34;,
            user = &#34;root&#34;,
            password = &#34;alex&#34;,
            database = &#34;expenses&#34;
        )
        cursor = mydb.cursor()
        try:
            for expense in self._expenses:
                cursor.execute(f&#34;&#34;&#34;INSERT INTO expenses(
        day, amount, type)
         VALUES ({str(expense.day)}, {str(expense.amount)}, &#39;{str(expense.type)}&#39;)&#34;&#34;&#34;)
            mydb.commit()
        except:
            mydb.rollback()
        mydb.close()


    def __getitem__(self, index: int) -&gt; None:
        &#34;&#34;&#34;
        Magic method to return the Expense at a given index in _expenses, when an object of this class is called like a list, i.e., repo[index]
        :param index: The index of the expense to return
        :return: The expense at that index
        &#34;&#34;&#34;
        return self._expenses[index]

    @staticmethod
    def expense_to_json_format(expense: Expense) -&gt; dict:
        &#34;&#34;&#34;
        Returns the json format (dictionary) of an object of class Expense
        :param expense: The expense we are converting
        :return: The JSON format of the expense
        &#34;&#34;&#34;
        json_expense = {&#34;day&#34;: expense.day, &#34;amount&#34;: expense.amount, &#34;type&#34;: expense.type}
        return json_expense

    def __generate_expenses(self, number_of_expenses: int) -&gt; None:
        &#34;&#34;&#34;
        A private method to generate n random expenses to put in the list that is empty, in memory
        :param number_of_expenses: The number of expenses to generate
        :return: None
        &#34;&#34;&#34;
        for index in range(number_of_expenses):
            day = randint(1, 30)
            amount = randint(1, 1000    )
            type = chr(ord(&#34;a&#34;)+index)
            self.add(day, amount, type)

    def add(self, day: int, amount: int, type: str) -&gt; None:
        &#34;&#34;&#34;
        Adds a new expense given by its day, amount and type to the list of expenses in memory
        :param day: Day of expense
        :param amount: Amount in money of expense cost
        :param type: Type of expense
        :return: None
        &#34;&#34;&#34;
        self._expenses.append(Expense(day, amount, type))

    def remove(self, index: int) -&gt; None:
        &#34;&#34;&#34;
        Removes an Expense at a given index from the list of expenses in memory
        :param index: The index of the expense to be removed
        :return: None
        &#34;&#34;&#34;
        self._expenses.pop(index)

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;
        Returns the length of the list of expenses from memory when len() is called on an instance of this class
        :return: The length of the list of expenses from this repository
        &#34;&#34;&#34;
        return len(self._expenses)

    def undo(self, last_expenses: list[Expense]) -&gt; None:
        &#34;&#34;&#34;
            Goes back one change made to expenses, the argument is the last list of the history container from the Services class.
            :param last_expenses: The list of expenses without the last change
            :return: None
        &#34;&#34;&#34;
        self._expenses = last_expenses</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="repository.BinaryRepository" href="#repository.BinaryRepository">BinaryRepository</a></li>
<li><a title="repository.DBRepository" href="#repository.DBRepository">DBRepository</a></li>
<li><a title="repository.JSONRepository" href="#repository.JSONRepository">JSONRepository</a></li>
<li><a title="repository.TextFileRepository" href="#repository.TextFileRepository">TextFileRepository</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="repository.MemoryRepository.CREATE_TABLE_STRING"><code class="name">var <span class="ident">CREATE_TABLE_STRING</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="repository.MemoryRepository.DROP_TABLE_STRING"><code class="name">var <span class="ident">DROP_TABLE_STRING</span></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="repository.MemoryRepository.expense_to_json_format"><code class="name flex">
<span>def <span class="ident">expense_to_json_format</span></span>(<span>expense: src.domain.expense.Expense) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the json format (dictionary) of an object of class Expense
:param expense: The expense we are converting
:return: The JSON format of the expense</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="repository.MemoryRepository.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, day: int, amount: int, type: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new expense given by its day, amount and type to the list of expenses in memory
:param day: Day of expense
:param amount: Amount in money of expense cost
:param type: Type of expense
:return: None</p></div>
</dd>
<dt id="repository.MemoryRepository.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, index: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Removes an Expense at a given index from the list of expenses in memory
:param index: The index of the expense to be removed
:return: None</p></div>
</dd>
<dt id="repository.MemoryRepository.undo"><code class="name flex">
<span>def <span class="ident">undo</span></span>(<span>self, last_expenses: list[src.domain.expense.Expense]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Goes back one change made to expenses, the argument is the last list of the history container from the Services class.
:param last_expenses: The list of expenses without the last change
:return: None</p></div>
</dd>
</dl>
</dd>
<dt id="repository.TextFileRepository"><code class="flex name class">
<span>class <span class="ident">TextFileRepository</span></span>
<span>(</span><span>text_file_path: str = 'repository/expenses.txt')</span>
</code></dt>
<dd>
<div class="desc"><p>This class handles Expenses stored in a text file, in their string format, each expense string on a line.</p>
<p>It inherits from the MemoryRepository class, because it makes use of the add() and remove() methods from it, and it also instantiates a list of expenses in memory, that updates at the same time as the text file.
We work with that list of expenses in memory for Services compatibility, so we make use of the MemoryRepository class methods too.</p>
<p>However, in this class we have load and save methods, which load the Expenses from the text file into the list of expenses in memory, and, respectively, output the list of expenses from memory into the text file, in string format of each Expense.</p>
<p>Initializes by loading into a list of expenses from memory, the expenses from the text file found at a given relative path.</p>
<p>The initializer of the class TextFileRepository
:param text_file_path: The path of the text file we work with</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TextFileRepository(MemoryRepository):
    &#34;&#34;&#34;
    This class handles Expenses stored in a text file, in their string format, each expense string on a line.

    It inherits from the MemoryRepository class, because it makes use of the add() and remove() methods from it, and it also instantiates a list of expenses in memory, that updates at the same time as the text file.
    We work with that list of expenses in memory for Services compatibility, so we make use of the MemoryRepository class methods too.

    However, in this class we have load and save methods, which load the Expenses from the text file into the list of expenses in memory, and, respectively, output the list of expenses from memory into the text file, in string format of each Expense.

    Initializes by loading into a list of expenses from memory, the expenses from the text file found at a given relative path.
    &#34;&#34;&#34;
    def __init__(self, text_file_path: str = &#34;repository/expenses.txt&#34;):
        &#34;&#34;&#34;
        The initializer of the class TextFileRepository
        :param text_file_path: The path of the text file we work with
        &#34;&#34;&#34;
        super().__init__(0)
        self.__text_file_path = text_file_path
        self.__load()

    @staticmethod
    def str_to_expense(str_form: list[str]) -&gt; list:
        &#34;&#34;&#34;
        Return the expense made from parsing its string form, split into multiple words.
        :param str_form: The list of strings from its string form
        :return: The Expense corresponding to this list of strings.
        &#34;&#34;&#34;
        return [int(str_form[8]), int(str_form[10]), str_form[3]]

    def __load(self) -&gt; None:
        &#34;&#34;&#34;
        Loads the expenses from the text file into memory (expenses list)
        :return: None
        &#34;&#34;&#34;
        with open(self.__text_file_path, &#34;r&#34;) as file:
            lines = file.readlines()
            for line in lines:
                expense_attributes = self.str_to_expense(line.strip(&#34;\n&#34;).split(&#34; &#34;))
                self._expenses.append(Expense(expense_attributes[0], expense_attributes[1], expense_attributes[2]))
            # Add to the list of expenses the expense made from the string of the line in the file without \n

    def __save(self) -&gt; None:
        &#34;&#34;&#34;
        Saves the list of expenses from memory into string format in the text file.
        :return: None
        &#34;&#34;&#34;
        with open(self.__text_file_path, &#34;w&#34;) as file:
            for expense in self._expenses:
                file.write(f&#34;{str(expense)}\n&#34;) # uses __str__ from Expense class

    def add(self, day: int, amount: int, type: str) -&gt; None:
        &#34;&#34;&#34;
        Add an expense in the text file of expenses and also in the list of expenses from memory
        :param day: The day of the expense
        :param amount: The amount in money of the expense
        :param type: The type of the expense
        :return: None
        &#34;&#34;&#34;
        super().add(day, amount, type)
        self.__save()

    def remove(self, index: int) -&gt; None:
        &#34;&#34;&#34;
        Removes an expense from expenses.txt and also from the list of expenses in the text file repository
        :param index: The index of that expense in the list of expenses from memory.
        :return: None
        &#34;&#34;&#34;
        super().remove(index)
        self.__save()

    def undo(self, last_expenses: list[Expense]) -&gt; None:
        &#34;&#34;&#34;
            Goes back one change made to the list of expenses (consequently, modify the file too)
            :param last_expenses: The list of expenses without the last change
            :return: None
        &#34;&#34;&#34;
        self._expenses = last_expenses
        self.__save()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="repository.MemoryRepository" href="#repository.MemoryRepository">MemoryRepository</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="repository.TextFileRepository.str_to_expense"><code class="name flex">
<span>def <span class="ident">str_to_expense</span></span>(<span>str_form: list[str]) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Return the expense made from parsing its string form, split into multiple words.
:param str_form: The list of strings from its string form
:return: The Expense corresponding to this list of strings.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="repository.TextFileRepository.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, day: int, amount: int, type: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add an expense in the text file of expenses and also in the list of expenses from memory
:param day: The day of the expense
:param amount: The amount in money of the expense
:param type: The type of the expense
:return: None</p></div>
</dd>
<dt id="repository.TextFileRepository.remove"><code class="name flex">
<span>def <span class="ident">remove</span></span>(<span>self, index: int) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Removes an expense from expenses.txt and also from the list of expenses in the text file repository
:param index: The index of that expense in the list of expenses from memory.
:return: None</p></div>
</dd>
<dt id="repository.TextFileRepository.undo"><code class="name flex">
<span>def <span class="ident">undo</span></span>(<span>self, last_expenses: list[src.domain.expense.Expense]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Goes back one change made to the list of expenses (consequently, modify the file too)
:param last_expenses: The list of expenses without the last change
:return: None</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="repository.MemoryRepository" href="#repository.MemoryRepository">MemoryRepository</a></b></code>:
<ul class="hlist">
<li><code><a title="repository.MemoryRepository.CREATE_TABLE_STRING" href="#repository.MemoryRepository.CREATE_TABLE_STRING">CREATE_TABLE_STRING</a></code></li>
<li><code><a title="repository.MemoryRepository.DROP_TABLE_STRING" href="#repository.MemoryRepository.DROP_TABLE_STRING">DROP_TABLE_STRING</a></code></li>
<li><code><a title="repository.MemoryRepository.expense_to_json_format" href="#repository.MemoryRepository.expense_to_json_format">expense_to_json_format</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="repository.BinaryRepository" href="#repository.BinaryRepository">BinaryRepository</a></code></h4>
<ul class="">
<li><code><a title="repository.BinaryRepository.add" href="#repository.BinaryRepository.add">add</a></code></li>
<li><code><a title="repository.BinaryRepository.remove" href="#repository.BinaryRepository.remove">remove</a></code></li>
<li><code><a title="repository.BinaryRepository.undo" href="#repository.BinaryRepository.undo">undo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="repository.DBRepository" href="#repository.DBRepository">DBRepository</a></code></h4>
<ul class="">
<li><code><a title="repository.DBRepository.add" href="#repository.DBRepository.add">add</a></code></li>
<li><code><a title="repository.DBRepository.remove" href="#repository.DBRepository.remove">remove</a></code></li>
<li><code><a title="repository.DBRepository.undo" href="#repository.DBRepository.undo">undo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="repository.JSONRepository" href="#repository.JSONRepository">JSONRepository</a></code></h4>
<ul class="">
<li><code><a title="repository.JSONRepository.add" href="#repository.JSONRepository.add">add</a></code></li>
<li><code><a title="repository.JSONRepository.remove" href="#repository.JSONRepository.remove">remove</a></code></li>
<li><code><a title="repository.JSONRepository.undo" href="#repository.JSONRepository.undo">undo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="repository.MemoryRepository" href="#repository.MemoryRepository">MemoryRepository</a></code></h4>
<ul class="">
<li><code><a title="repository.MemoryRepository.CREATE_TABLE_STRING" href="#repository.MemoryRepository.CREATE_TABLE_STRING">CREATE_TABLE_STRING</a></code></li>
<li><code><a title="repository.MemoryRepository.DROP_TABLE_STRING" href="#repository.MemoryRepository.DROP_TABLE_STRING">DROP_TABLE_STRING</a></code></li>
<li><code><a title="repository.MemoryRepository.add" href="#repository.MemoryRepository.add">add</a></code></li>
<li><code><a title="repository.MemoryRepository.expense_to_json_format" href="#repository.MemoryRepository.expense_to_json_format">expense_to_json_format</a></code></li>
<li><code><a title="repository.MemoryRepository.remove" href="#repository.MemoryRepository.remove">remove</a></code></li>
<li><code><a title="repository.MemoryRepository.undo" href="#repository.MemoryRepository.undo">undo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="repository.TextFileRepository" href="#repository.TextFileRepository">TextFileRepository</a></code></h4>
<ul class="">
<li><code><a title="repository.TextFileRepository.add" href="#repository.TextFileRepository.add">add</a></code></li>
<li><code><a title="repository.TextFileRepository.remove" href="#repository.TextFileRepository.remove">remove</a></code></li>
<li><code><a title="repository.TextFileRepository.str_to_expense" href="#repository.TextFileRepository.str_to_expense">str_to_expense</a></code></li>
<li><code><a title="repository.TextFileRepository.undo" href="#repository.TextFileRepository.undo">undo</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
